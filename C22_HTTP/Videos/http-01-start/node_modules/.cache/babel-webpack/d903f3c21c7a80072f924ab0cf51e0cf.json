{"ast":null,"code":"import { Observable } from '../Observable';\nimport { argsArgArrayOrObject } from '../util/argsArgArrayOrObject';\nimport { from } from './from';\nimport { identity } from '../util/identity';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { popResultSelector, popScheduler } from '../util/args';\nimport { createObject } from '../util/createObject';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { executeSchedule } from '../util/executeSchedule';\nexport function combineLatest() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var scheduler = popScheduler(args);\n  var resultSelector = popResultSelector(args);\n\n  var _argsArgArrayOrObject = argsArgArrayOrObject(args),\n      observables = _argsArgArrayOrObject.args,\n      keys = _argsArgArrayOrObject.keys;\n\n  if (observables.length === 0) {\n    return from([], scheduler);\n  }\n\n  var result = new Observable(combineLatestInit(observables, scheduler, keys ? function (values) {\n    return createObject(keys, values);\n  } : identity));\n  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;\n}\nexport function combineLatestInit(observables, scheduler) {\n  var valueTransform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity;\n  return function (subscriber) {\n    maybeSchedule(scheduler, function () {\n      var length = observables.length;\n      var values = new Array(length);\n      var active = length;\n      var remainingFirstValues = length;\n\n      var _loop = function _loop(i) {\n        maybeSchedule(scheduler, function () {\n          var source = from(observables[i], scheduler);\n          var hasFirstValue = false;\n          source.subscribe(createOperatorSubscriber(subscriber, function (value) {\n            values[i] = value;\n\n            if (!hasFirstValue) {\n              hasFirstValue = true;\n              remainingFirstValues--;\n            }\n\n            if (!remainingFirstValues) {\n              subscriber.next(valueTransform(values.slice()));\n            }\n          }, function () {\n            if (! --active) {\n              subscriber.complete();\n            }\n          }));\n        }, subscriber);\n      };\n\n      for (var i = 0; i < length; i++) {\n        _loop(i);\n      }\n    }, subscriber);\n  };\n}\n\nfunction maybeSchedule(scheduler, execute, subscription) {\n  if (scheduler) {\n    executeSchedule(subscription, scheduler, execute);\n  } else {\n    execute();\n  }\n}","map":{"version":3,"sources":["../../../../src/internal/observable/combineLatest.ts"],"names":[],"mappings":"AAAA,SAAS,UAAT,QAA2B,eAA3B;AAEA,SAAS,oBAAT,QAAqC,8BAArC;AAEA,SAAS,IAAT,QAAqB,QAArB;AACA,SAAS,QAAT,QAAyB,kBAAzB;AAEA,SAAS,gBAAT,QAAiC,0BAAjC;AACA,SAAS,iBAAT,EAA4B,YAA5B,QAAgD,cAAhD;AACA,SAAS,YAAT,QAA6B,sBAA7B;AACA,SAAS,wBAAT,QAAyC,iCAAzC;AAEA,SAAS,eAAT,QAAgC,yBAAhC;AA4LA,OAAM,SAAU,aAAV,GAAyE;AAAA,oCAAX,IAAW;AAAX,IAAA,IAAW;AAAA;;AAC7E,MAAM,SAAS,GAAG,YAAY,CAAC,IAAD,CAA9B;AACA,MAAM,cAAc,GAAG,iBAAiB,CAAC,IAAD,CAAxC;;AAEA,8BAAoC,oBAAoB,CAAC,IAAD,CAAxD;AAAA,MAAc,WAAd,yBAAQ,IAAR;AAAA,MAA2B,IAA3B,yBAA2B,IAA3B;;AAEA,MAAI,WAAW,CAAC,MAAZ,KAAuB,CAA3B,EAA8B;AAI5B,WAAO,IAAI,CAAC,EAAD,EAAK,SAAL,CAAX;AACD;;AAED,MAAM,MAAM,GAAG,IAAI,UAAJ,CACb,iBAAiB,CACf,WADe,EAEf,SAFe,EAGf,IAAI,GAEA,UAAC,MAAD;AAAA,WAAY,YAAY,CAAC,IAAD,EAAO,MAAP,CAAxB;AAAA,GAFA,GAIA,QAPW,CADJ,CAAf;AAYA,SAAO,cAAc,GAAI,MAAM,CAAC,IAAP,CAAY,gBAAgB,CAAC,cAAD,CAA5B,CAAJ,GAAsE,MAA3F;AACD;AAED,OAAM,SAAU,iBAAV,CACJ,WADI,EAEJ,SAFI,EAG6C;AAAA,MAAjD,cAAiD,uEAAR,QAAQ;AAEjD,SAAO,UAAC,UAAD,EAAgC;AAGrC,IAAA,aAAa,CACX,SADW,EAEX,YAAK;AACH,UAAQ,MAAR,GAAmB,WAAnB,CAAQ,MAAR;AAEA,UAAM,MAAM,GAAG,IAAI,KAAJ,CAAU,MAAV,CAAf;AAGA,UAAI,MAAM,GAAG,MAAb;AAIA,UAAI,oBAAoB,GAAG,MAA3B;;AAVG,iCAaM,CAbN;AAcD,QAAA,aAAa,CACX,SADW,EAEX,YAAK;AACH,cAAM,MAAM,GAAG,IAAI,CAAC,WAAW,CAAC,CAAD,CAAZ,EAAiB,SAAjB,CAAnB;AACA,cAAI,aAAa,GAAG,KAApB;AACA,UAAA,MAAM,CAAC,SAAP,CACE,wBAAwB,CACtB,UADsB,EAEtB,UAAC,KAAD,EAAU;AAER,YAAA,MAAM,CAAC,CAAD,CAAN,GAAY,KAAZ;;AACA,gBAAI,CAAC,aAAL,EAAoB;AAElB,cAAA,aAAa,GAAG,IAAhB;AACA,cAAA,oBAAoB;AACrB;;AACD,gBAAI,CAAC,oBAAL,EAA2B;AAGzB,cAAA,UAAU,CAAC,IAAX,CAAgB,cAAc,CAAC,MAAM,CAAC,KAAP,EAAD,CAA9B;AACD;AACF,WAfqB,EAgBtB,YAAK;AACH,gBAAI,CAAC,GAAE,MAAP,EAAe;AAGb,cAAA,UAAU,CAAC,QAAX;AACD;AACF,WAtBqB,CAD1B;AA0BD,SA/BU,EAgCX,UAhCW,CAAb;AAdC;;AAaH,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAApB,EAA4B,CAAC,EAA7B,EAAiC;AAAA,cAAxB,CAAwB;AAmChC;AACF,KAnDU,EAoDX,UApDW,CAAb;AAsDD,GAzDD;AA0DD;;AAMD,SAAS,aAAT,CAAuB,SAAvB,EAA6D,OAA7D,EAAkF,YAAlF,EAA4G;AAC1G,MAAI,SAAJ,EAAe;AACb,IAAA,eAAe,CAAC,YAAD,EAAe,SAAf,EAA0B,OAA1B,CAAf;AACD,GAFD,MAEO;AACL,IAAA,OAAO;AACR;AACF","sourceRoot":"","sourcesContent":["import { Observable } from '../Observable';\nimport { argsArgArrayOrObject } from '../util/argsArgArrayOrObject';\nimport { from } from './from';\nimport { identity } from '../util/identity';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { popResultSelector, popScheduler } from '../util/args';\nimport { createObject } from '../util/createObject';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { executeSchedule } from '../util/executeSchedule';\nexport function combineLatest(...args) {\n    const scheduler = popScheduler(args);\n    const resultSelector = popResultSelector(args);\n    const { args: observables, keys } = argsArgArrayOrObject(args);\n    if (observables.length === 0) {\n        return from([], scheduler);\n    }\n    const result = new Observable(combineLatestInit(observables, scheduler, keys\n        ?\n            (values) => createObject(keys, values)\n        :\n            identity));\n    return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;\n}\nexport function combineLatestInit(observables, scheduler, valueTransform = identity) {\n    return (subscriber) => {\n        maybeSchedule(scheduler, () => {\n            const { length } = observables;\n            const values = new Array(length);\n            let active = length;\n            let remainingFirstValues = length;\n            for (let i = 0; i < length; i++) {\n                maybeSchedule(scheduler, () => {\n                    const source = from(observables[i], scheduler);\n                    let hasFirstValue = false;\n                    source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n                        values[i] = value;\n                        if (!hasFirstValue) {\n                            hasFirstValue = true;\n                            remainingFirstValues--;\n                        }\n                        if (!remainingFirstValues) {\n                            subscriber.next(valueTransform(values.slice()));\n                        }\n                    }, () => {\n                        if (!--active) {\n                            subscriber.complete();\n                        }\n                    }));\n                }, subscriber);\n            }\n        }, subscriber);\n    };\n}\nfunction maybeSchedule(scheduler, execute, subscription) {\n    if (scheduler) {\n        executeSchedule(subscription, scheduler, execute);\n    }\n    else {\n        execute();\n    }\n}\n//# sourceMappingURL=combineLatest.js.map"]},"metadata":{},"sourceType":"module"}