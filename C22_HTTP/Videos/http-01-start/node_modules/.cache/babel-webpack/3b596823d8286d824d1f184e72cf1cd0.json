{"ast":null,"code":"import { asyncScheduler } from '../scheduler/async';\nimport { isValidDate } from '../util/isDate';\nimport { operate } from '../util/lift';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createErrorClass } from '../util/createErrorClass';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { executeSchedule } from '../util/executeSchedule';\nexport var TimeoutError = createErrorClass(function (_super) {\n  return function TimeoutErrorImpl() {\n    var info = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _super(this);\n\n    this.message = 'Timeout has occurred';\n    this.name = 'TimeoutError';\n    this.info = info;\n  };\n});\nexport function timeout(config, schedulerArg) {\n  var _ref = isValidDate(config) ? {\n    first: config\n  } : typeof config === 'number' ? {\n    each: config\n  } : config,\n      first = _ref.first,\n      each = _ref.each,\n      _ref$with = _ref.with,\n      _with = _ref$with === void 0 ? timeoutErrorFactory : _ref$with,\n      _ref$scheduler = _ref.scheduler,\n      scheduler = _ref$scheduler === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : asyncScheduler : _ref$scheduler,\n      _ref$meta = _ref.meta,\n      meta = _ref$meta === void 0 ? null : _ref$meta;\n\n  if (first == null && each == null) {\n    throw new TypeError('No timeout provided.');\n  }\n\n  return operate(function (source, subscriber) {\n    var originalSourceSubscription;\n    var timerSubscription;\n    var lastValue = null;\n    var seen = 0;\n\n    var startTimer = function startTimer(delay) {\n      timerSubscription = executeSchedule(subscriber, scheduler, function () {\n        try {\n          originalSourceSubscription.unsubscribe();\n          innerFrom(_with({\n            meta: meta,\n            lastValue: lastValue,\n            seen: seen\n          })).subscribe(subscriber);\n        } catch (err) {\n          subscriber.error(err);\n        }\n      }, delay);\n    };\n\n    originalSourceSubscription = source.subscribe(createOperatorSubscriber(subscriber, function (value) {\n      timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();\n      seen++;\n      subscriber.next(lastValue = value);\n      each > 0 && startTimer(each);\n    }, undefined, undefined, function () {\n      if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {\n        timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();\n      }\n\n      lastValue = null;\n    }));\n    !seen && startTimer(first != null ? typeof first === 'number' ? first : +first - scheduler.now() : each);\n  });\n}\n\nfunction timeoutErrorFactory(info) {\n  throw new TimeoutError(info);\n}","map":{"version":3,"sources":["../../../../src/internal/operators/timeout.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { asyncScheduler } from '../scheduler/async';\nimport { isValidDate } from '../util/isDate';\nimport { operate } from '../util/lift';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createErrorClass } from '../util/createErrorClass';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { executeSchedule } from '../util/executeSchedule';\nexport const TimeoutError = createErrorClass((_super) => function TimeoutErrorImpl(info = null) {\n    _super(this);\n    this.message = 'Timeout has occurred';\n    this.name = 'TimeoutError';\n    this.info = info;\n});\nexport function timeout(config, schedulerArg) {\n    const { first, each, with: _with = timeoutErrorFactory, scheduler = schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : asyncScheduler, meta = null, } = (isValidDate(config) ? { first: config } : typeof config === 'number' ? { each: config } : config);\n    if (first == null && each == null) {\n        throw new TypeError('No timeout provided.');\n    }\n    return operate((source, subscriber) => {\n        let originalSourceSubscription;\n        let timerSubscription;\n        let lastValue = null;\n        let seen = 0;\n        const startTimer = (delay) => {\n            timerSubscription = executeSchedule(subscriber, scheduler, () => {\n                try {\n                    originalSourceSubscription.unsubscribe();\n                    innerFrom(_with({\n                        meta,\n                        lastValue,\n                        seen,\n                    })).subscribe(subscriber);\n                }\n                catch (err) {\n                    subscriber.error(err);\n                }\n            }, delay);\n        };\n        originalSourceSubscription = source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();\n            seen++;\n            subscriber.next((lastValue = value));\n            each > 0 && startTimer(each);\n        }, undefined, undefined, () => {\n            if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {\n                timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();\n            }\n            lastValue = null;\n        }));\n        !seen && startTimer(first != null ? (typeof first === 'number' ? first : +first - scheduler.now()) : each);\n    });\n}\nfunction timeoutErrorFactory(info) {\n    throw new TimeoutError(info);\n}\n//# sourceMappingURL=timeout.js.map"]},"metadata":{},"sourceType":"module"}