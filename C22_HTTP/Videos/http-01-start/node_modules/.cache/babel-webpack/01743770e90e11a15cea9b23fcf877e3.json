{"ast":null,"code":"import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber, OperatorSubscriber } from './OperatorSubscriber';\nexport function groupBy(keySelector, elementOrOptions, duration, connector) {\n  return operate(function (source, subscriber) {\n    var element;\n\n    if (!elementOrOptions || typeof elementOrOptions === 'function') {\n      element = elementOrOptions;\n    } else {\n      duration = elementOrOptions.duration;\n      element = elementOrOptions.element;\n      connector = elementOrOptions.connector;\n    }\n\n    var groups = new Map();\n\n    var notify = function notify(cb) {\n      groups.forEach(cb);\n      cb(subscriber);\n    };\n\n    var handleError = function handleError(err) {\n      return notify(function (consumer) {\n        return consumer.error(err);\n      });\n    };\n\n    var activeGroups = 0;\n    var teardownAttempted = false;\n    var groupBySourceSubscriber = new OperatorSubscriber(subscriber, function (value) {\n      try {\n        var key = keySelector(value);\n        var group = groups.get(key);\n\n        if (!group) {\n          groups.set(key, group = connector ? connector() : new Subject());\n          var grouped = createGroupedObservable(key, group);\n          subscriber.next(grouped);\n\n          if (duration) {\n            var durationSubscriber = createOperatorSubscriber(group, function () {\n              group.complete();\n              durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();\n            }, undefined, undefined, function () {\n              return groups.delete(key);\n            });\n            groupBySourceSubscriber.add(innerFrom(duration(grouped)).subscribe(durationSubscriber));\n          }\n        }\n\n        group.next(element ? element(value) : value);\n      } catch (err) {\n        handleError(err);\n      }\n    }, function () {\n      return notify(function (consumer) {\n        return consumer.complete();\n      });\n    }, handleError, function () {\n      return groups.clear();\n    }, function () {\n      teardownAttempted = true;\n      return activeGroups === 0;\n    });\n    source.subscribe(groupBySourceSubscriber);\n\n    function createGroupedObservable(key, groupSubject) {\n      var result = new Observable(function (groupSubscriber) {\n        activeGroups++;\n        var innerSub = groupSubject.subscribe(groupSubscriber);\n        return function () {\n          innerSub.unsubscribe();\n          --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();\n        };\n      });\n      result.key = key;\n      return result;\n    }\n  });\n}","map":{"version":3,"sources":["../../../../src/internal/operators/groupBy.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber, OperatorSubscriber } from './OperatorSubscriber';\nexport function groupBy(keySelector, elementOrOptions, duration, connector) {\n    return operate((source, subscriber) => {\n        let element;\n        if (!elementOrOptions || typeof elementOrOptions === 'function') {\n            element = elementOrOptions;\n        }\n        else {\n            ({ duration, element, connector } = elementOrOptions);\n        }\n        const groups = new Map();\n        const notify = (cb) => {\n            groups.forEach(cb);\n            cb(subscriber);\n        };\n        const handleError = (err) => notify((consumer) => consumer.error(err));\n        let activeGroups = 0;\n        let teardownAttempted = false;\n        const groupBySourceSubscriber = new OperatorSubscriber(subscriber, (value) => {\n            try {\n                const key = keySelector(value);\n                let group = groups.get(key);\n                if (!group) {\n                    groups.set(key, (group = connector ? connector() : new Subject()));\n                    const grouped = createGroupedObservable(key, group);\n                    subscriber.next(grouped);\n                    if (duration) {\n                        const durationSubscriber = createOperatorSubscriber(group, () => {\n                            group.complete();\n                            durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();\n                        }, undefined, undefined, () => groups.delete(key));\n                        groupBySourceSubscriber.add(innerFrom(duration(grouped)).subscribe(durationSubscriber));\n                    }\n                }\n                group.next(element ? element(value) : value);\n            }\n            catch (err) {\n                handleError(err);\n            }\n        }, () => notify((consumer) => consumer.complete()), handleError, () => groups.clear(), () => {\n            teardownAttempted = true;\n            return activeGroups === 0;\n        });\n        source.subscribe(groupBySourceSubscriber);\n        function createGroupedObservable(key, groupSubject) {\n            const result = new Observable((groupSubscriber) => {\n                activeGroups++;\n                const innerSub = groupSubject.subscribe(groupSubscriber);\n                return () => {\n                    innerSub.unsubscribe();\n                    --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();\n                };\n            });\n            result.key = key;\n            return result;\n        }\n    });\n}\n//# sourceMappingURL=groupBy.js.map"]},"metadata":{},"sourceType":"module"}